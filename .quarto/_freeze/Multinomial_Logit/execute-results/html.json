{
  "hash": "1c50841929bd1ca46dd82e571f38d924",
  "result": {
    "markdown": "---\ntitle: \"Multinomial Logit Example\"\n---\n\n\n\n\n# introduction\n\nIn this document I'll demonstrate merger simulation with a synthetic example. On the supply side assuming a differentiated Bertrand model and on the demand side assuming a multinomial logit demand function.\n\nThe Bertrand system of equations has 4 components:\\\n(1) Market shares.\\\n(2) Prices.\\\n(3) Derivatives of the demand function with respect to the prices.\\\n(4) Marginal costs of the firms.\n\n# Pre merger conditions\n\nFor the sake of demonstration the market shares chosen are `0.2, 0.25` and `0.3`.\\\nprices are `50, 75` and `80` correspondingly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. market shares\ns <- c(0.2, 0.25, 0.3) \n\n# outside option market share\n(s_0 <- 1 - sum(s) )\n## [1] 0.25\n# 2. prices\np <- c(50, 75, 80)\n```\n:::\n\n\n**Calculation of derivatives**\\\nThe logit derivative is a function of market shares and the consumer's derivative with respect to the price - the model's $alpha$. we'll choose $alpha$ to be 0.1. In fact, this is a calibration of the system. One can estimate those parameters with a demand estimation (which is beyond the scope of this simple document).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3. derivatives\n# choose alpha  \nalpha <- - 0.1\n\n# derivatives are functions of market shares and alpha\n# own derivative\n(d_sj_d_pj <- alpha * (1-s) * s)\n## [1] -0.0160 -0.0188 -0.0210\n# cross derivative\n(d_sk_d_pj <- - alpha * s %o% s)\n##       [,1]    [,2]   [,3]\n## [1,] 0.004 0.00500 0.0060\n## [2,] 0.005 0.00625 0.0075\n## [3,] 0.006 0.00750 0.0090\n# put own derivatives in diagonal\nder <- d_sk_d_pj\ndiag(der) <- d_sj_d_pj\n\n# final result\nder\n##        [,1]    [,2]    [,3]\n## [1,] -0.016  0.0050  0.0060\n## [2,]  0.005 -0.0188  0.0075\n## [3,]  0.006  0.0075 -0.0210\n```\n:::\n\n\nNote that the diagonal is negative -\\> self elasticity is negative, and the off-diagonal are positive which means products are substitutes.\n\n**Solving the equation system for the marginal costs**\\\nAs stated above, First order condition has 4 components.\\\nWe have supplied the market shares, the prices and the derivatives. Next, we solve the system for the marginal costs.\n\nFor the solution we create the \"owner ship\" matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 4. solving a system of equations for the marginal costs\n# ownership matrix\n(theta <- matrix( c(1,0,0,0,1,0,0,0,1), nrow = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n:::\n\n```{.r .cell-code}\n# solve a system of linear equations\n(mc <- solve(theta * der) %*% s + p )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,] 37.5\n[2,] 61.7\n[3,] 65.7\n```\n:::\n:::\n\n\nWe can check the first order condition are valid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check that F.O.C's are met: \ns + (theta * der) %*% (p - mc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                       [,1]\n[1,] -0.0000000000000000278\n[2,]  0.0000000000000000555\n[3,] -0.0000000000000001110\n```\n:::\n:::\n\n\n# Merger simulate\n\n**A merger in the market**\\\nWhen a merger happens, the ownership of firms over the product set is changing. Next, we'll assume that products 1 and 2 are now under the same ownership. For that, we update the ownership matrix. The 1st and 2nd elements 1st and 2nd rows of the matrix will equal to 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# new ownership matrix: \n(theta_post <- matrix(c(1,1,0,1,1,0,0,0,1), nrow = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    1    0\n[2,]    1    1    0\n[3,]    0    0    1\n```\n:::\n:::\n\n\nChanging the ownership matrix resembles the change in the incentives the merged firm forgo. The firm understands that when the price of product 1 goes up, some of the customers that choose to not buy it anymore will by product 2. The closer substitutes are the products the larger proportion of customers will diverge between product 1 to 2 and vice versa. Hence for those customers, the firm does not loose its sails. With that knowledge, the firm can raise the price up. The first order condition is not valid anymore because the old price is not the optimal price.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# FOC don't hold\ns + (theta_post * der) %*% (p - mc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                      [,1]\n[1,]  0.066666666666666624\n[2,]  0.062500000000000056\n[3,] -0.000000000000000111\n```\n:::\n:::\n\n\n## Fixed point iteration\n\nThis change in the merged firm incentives has a ripple effect on the entire market. The firm will raise its prices, some of the customers will leave its products and either buy it at the competitors or not buy it at all. To compute this, we need an iterative process that will end in a new equilibrium.\n\nAssuming convexity and continuity of the equation system, we can find a solution and know it is unique.\n\naccording to the model , the average utility from product j is: $$ \\delta_j = x \\beta_j - \\alpha p + \\xi _j $$\\\nFor each product we calculate the average utility.\n\nA change in price will change the utility from the product. This in turn, will be reflected in the demand function, the demand decreases when the price goes up and vice versa.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# delta = x * b - alpha * p\n(delta <- log(s / s_0)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.223  0.000  0.182\n```\n:::\n\n```{.r .cell-code}\nexp(delta) / (1 + sum(exp(delta)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.20 0.25 0.30\n```\n:::\n:::\n\n\n## Manual iteration\n\nWe'll compute the first few iterations be hand to see how it converges.\\\nIn every iteration 4 stages will take place:\n\n(1) Solve the firms first order conditions subject to market shares to find a new price vector.\n(2) Calculate the change in the price vector compared to the pre-merger state.\n(3) feed the new prices to consumer utility functions to get the change in utilities.\n(4) Get the new market shares out from the demand function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the price update procedure: \n# 1. solve FOC 1\n(p1 <- as.vector(mc + (1/ - alpha) * (1 / (1 -  theta_post %*% s))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55.7 79.8 80.0\n```\n:::\n\n```{.r .cell-code}\n# 2. delta price\n(d_p <- (p1 - p))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.68 4.85 0.00\n```\n:::\n\n```{.r .cell-code}\n# 3. delta in utility\n(d_delta <- d_p * alpha)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.568 -0.485  0.000\n```\n:::\n\n```{.r .cell-code}\n# 4. solve demand for new utility\n(s1 <- exp(delta + d_delta) / (1 + sum(exp(delta + d_delta))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.139 0.188 0.367\n```\n:::\n:::\n\n\nGet the results and compere to the pre merger status.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <-rbind(c(s, p), c(s1, p1)) \nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]  [,2]  [,3] [,4] [,5] [,6]\n[1,] 0.200 0.250 0.300 50.0 75.0   80\n[2,] 0.139 0.188 0.367 55.7 79.8   80\n```\n:::\n:::\n\n\nRepeat the process several more times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# solve FOC 2:\np2 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s1)))\nd_p <- (p2 - p) \nd_delta <- d_p * alpha\n# solve demand 2:\ns2 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s2, p2))\n# solve FOC 3:\np3 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s2)))\nd_p <- (p3 - p) \nd_delta <- d_p * alpha\n# solve demand 3:\ns3 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s3, p3))\n# solve FOC 4:\np4 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s3)))\nd_p <- (p4 - p) \nd_delta <- d_p * alpha\n# solve demand 3:\ns4 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s4, p4))\n# solve FOC 5:\np5 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s4)))\nd_p <- (p5 - p) \nd_delta <- d_p * alpha\n# solve demand 3:\ns5 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s5, p5))\n# solve FOC 6:\np6 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s5)))\nd_p <- (p6 - p) \nd_delta <- d_p * alpha\n# solve demand\ns6 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s6, p6))\n# solve FOC 7:\np7 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s6)))\nd_p <- (p7 - p) \nd_delta <- d_p * alpha\n# solve demand\ns7 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s7, p7))\n# solve FOC 8:\np8 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s7)))\nd_p <- (p8 - p) \nd_delta <- d_p * alpha\n# solve demand\ns8 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\n```\n:::\n\n\nIn the `results` matrix, columns 1-3 are market shares and columns 4-6 are the prices.\\\nevery iteration the jumps in the values decreases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- rbind(results, c(s8, p8))\ncolnames(results) <- c('s1', 's2', 's3', 'p1', 'p2', 'p3')\nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         s1    s2    s3   p1   p2   p3\n [1,] 0.200 0.250 0.300 50.0 75.0 80.0\n [2,] 0.139 0.188 0.367 55.7 79.8 80.0\n [3,] 0.179 0.244 0.293 52.4 76.5 81.5\n [4,] 0.146 0.198 0.360 54.8 79.0 79.9\n [5,] 0.175 0.237 0.301 52.7 76.9 81.3\n [6,] 0.150 0.204 0.352 54.5 78.7 80.0\n [7,] 0.171 0.232 0.308 53.0 77.1 81.1\n [8,] 0.153 0.208 0.346 54.3 78.4 80.2\n [9,] 0.169 0.229 0.314 53.1 77.3 81.0\n```\n:::\n:::\n\n\nWe can see where it's going. the shares of products 1 and 2 are decreasing and product 3 is increasing. All prices are going up.\n\nLets calculate the new equilibrium.\n\n## While loop\n\nWe'll limit the number of iterations with `max_iter`, and document the convergence process in a `convergence_matrix` .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_iter <- 82 \ns_in <- s\ni <- 0\ns_delta_norm <- 1\nconvergence_matrix <- matrix(nrow = max_iter, ncol = length(s) * 2 + 2)\n\nwhile(s_delta_norm > 1e-6 & i < max_iter){\n  i <- i + 1\n  \n  # solve F.O.C\n  ( p_new <- as.vector(mc + (1/ - alpha ) * ( 1 / (1 -  theta_post %*% s_in) )))\n  \n  # change in utility\n  d_delta <- (p_new - p) * alpha\n  \n  # solve demand system\n  s_new <- exp(delta + d_delta) / (1 + sum(exp(delta + d_delta)))\n  \n  # norm of change in market shares\n  (s_delta_norm <- sqrt(sum((s_in - s_new) ^ 2)))\n  \n  # save resault for next iteration\n  s_in <- s_new\n  \n  convergence_matrix[i, ] <- c(s_new,  p_new, s_delta_norm, i)\n}\n\ncolnames(convergence_matrix) <- c(\"s1\", \"s2\", \"s3\", \"p1\", \"p2\", \"p3\", \"norm\", \"iteration\")\n\nconvergence_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         s1    s2    s3   p1   p2   p3        norm iteration\n [1,] 0.139 0.188 0.367 55.7 79.8 80.0 0.109827719         1\n [2,] 0.179 0.244 0.293 52.4 76.5 81.5 0.101188131         2\n [3,] 0.146 0.198 0.360 54.8 79.0 79.9 0.087867750         3\n [4,] 0.175 0.237 0.301 52.7 76.9 81.3 0.076132778         4\n [5,] 0.150 0.204 0.352 54.5 78.7 80.0 0.065389010         5\n [6,] 0.171 0.232 0.308 53.0 77.1 81.1 0.056301895         6\n [7,] 0.153 0.208 0.346 54.3 78.4 80.2 0.048324608         7\n [8,] 0.169 0.229 0.314 53.1 77.3 81.0 0.041574711         8\n [9,] 0.155 0.211 0.341 54.1 78.3 80.3 0.035693191         9\n[10,] 0.167 0.227 0.317 53.3 77.4 80.9 0.030698062        10\n[11,] 0.157 0.213 0.338 54.0 78.1 80.4 0.026361844        11\n[12,] 0.165 0.225 0.320 53.4 77.5 80.8 0.022667853        12\n[13,] 0.158 0.215 0.335 53.9 78.1 80.4 0.019469604        13\n[14,] 0.164 0.223 0.322 53.4 77.6 80.8 0.016738813        14\n[15,] 0.159 0.216 0.334 53.8 78.0 80.5 0.014379099        15\n[16,] 0.164 0.222 0.324 53.5 77.7 80.7 0.012360880        16\n[17,] 0.160 0.217 0.332 53.8 77.9 80.5 0.010619418        17\n[18,] 0.163 0.222 0.325 53.5 77.7 80.7 0.009128122        18\n[19,] 0.160 0.218 0.331 53.7 77.9 80.5 0.007842695        19\n[20,] 0.163 0.221 0.326 53.6 77.7 80.7 0.006740912        20\n[21,] 0.160 0.218 0.331 53.7 77.9 80.6 0.005791974        21\n[22,] 0.162 0.221 0.327 53.6 77.8 80.7 0.004978054        22\n[23,] 0.161 0.218 0.330 53.7 77.9 80.6 0.004277453        23\n[24,] 0.162 0.220 0.327 53.6 77.8 80.6 0.003676234        24\n[25,] 0.161 0.219 0.330 53.7 77.9 80.6 0.003158943        25\n[26,] 0.162 0.220 0.327 53.6 77.8 80.6 0.002714868        26\n[27,] 0.161 0.219 0.329 53.7 77.8 80.6 0.002332905        27\n[28,] 0.162 0.220 0.328 53.6 77.8 80.6 0.002004913        28\n[29,] 0.161 0.219 0.329 53.7 77.8 80.6 0.001722864        29\n[30,] 0.162 0.220 0.328 53.6 77.8 80.6 0.001480620        30\n[31,] 0.161 0.219 0.329 53.7 77.8 80.6 0.001272343        31\n[32,] 0.162 0.220 0.328 53.6 77.8 80.6 0.001093433        32\n[33,] 0.161 0.219 0.329 53.7 77.8 80.6 0.000939630        33\n[34,] 0.162 0.220 0.328 53.6 77.8 80.6 0.000807498        34\n[35,] 0.161 0.219 0.329 53.7 77.8 80.6 0.000693919        35\n[36,] 0.162 0.220 0.328 53.6 77.8 80.6 0.000596336        36\n[37,] 0.161 0.219 0.329 53.7 77.8 80.6 0.000512461        37\n[38,] 0.162 0.219 0.328 53.6 77.8 80.6 0.000440394        38\n[39,] 0.161 0.219 0.329 53.7 77.8 80.6 0.000378453        39\n[40,] 0.162 0.219 0.328 53.6 77.8 80.6 0.000325231        40\n[41,] 0.161 0.219 0.329 53.7 77.8 80.6 0.000279488        41\n[42,] 0.162 0.219 0.328 53.6 77.8 80.6 0.000240183        42\n[43,] 0.161 0.219 0.329 53.7 77.8 80.6 0.000206402        43\n[44,] 0.161 0.219 0.328 53.6 77.8 80.6 0.000177375        44\n[45,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000152428        45\n[46,] 0.161 0.219 0.328 53.6 77.8 80.6 0.000130991        46\n[47,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000112568        47\n[48,] 0.161 0.219 0.328 53.6 77.8 80.6 0.000096737        48\n[49,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000083132        49\n[50,] 0.161 0.219 0.328 53.6 77.8 80.6 0.000071440        50\n[51,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000061393        51\n[52,] 0.161 0.219 0.328 53.6 77.8 80.6 0.000052759        52\n[53,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000045339        53\n[54,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000038962        54\n[55,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000033483        55\n[56,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000028774        56\n[57,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000024727        57\n[58,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000021249        58\n[59,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000018261        59\n[60,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000015693        60\n[61,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000013486        61\n[62,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000011589        62\n[63,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000009959        63\n[64,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000008559        64\n[65,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000007355        65\n[66,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000006320        66\n[67,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000005432        67\n[68,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000004668        68\n[69,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000004011        69\n[70,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000003447        70\n[71,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000002962        71\n[72,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000002546        72\n[73,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000002188        73\n[74,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000001880        74\n[75,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000001616        75\n[76,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000001388        76\n[77,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000001193        77\n[78,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000001025        78\n[79,] 0.161 0.219 0.328 53.7 77.8 80.6 0.000000881        79\n[80,]    NA    NA    NA   NA   NA   NA          NA        NA\n[81,]    NA    NA    NA   NA   NA   NA          NA        NA\n[82,]    NA    NA    NA   NA   NA   NA          NA        NA\n```\n:::\n:::\n\n\nCompare the data before the merger with the prediction of the simulation about the merger effect on prices and market shares\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# attach preconditions with last row without NA's in the matrix\nfinal_resault <- \n  convergence_matrix[tail(which(rowSums(!is.na(convergence_matrix)) > 0), 1),]\n\n\nrbind(c(results[1,],norm = NA,iteration = 0),final_resault)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                 s1    s2    s3   p1   p2   p3        norm iteration\n              0.200 0.250 0.300 50.0 75.0 80.0          NA         0\nfinal_resault 0.161 0.219 0.328 53.7 77.8 80.6 0.000000881        79\n```\n:::\n:::\n\n\nThe market share of the outside option has increased:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(before = s_0, after = 1 - sum(final_resault[1:3]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbefore  after \n 0.250  0.291 \n```\n:::\n:::\n\n\nPresent convergence process on a plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, patchwork)\n\np1 <- data.frame(convergence_matrix) %>%\n  select(iteration, p1, p2, p3) %>%\n  gather(k = \"k\", v = \"prices\", 2:4) %>%\n  ggplot(aes(x = iteration, y = prices, color = k)) + geom_line(size = 1.2)\n\np2 <- data.frame(convergence_matrix) %>%\n  select(iteration, s1, s2, s3) %>%\n  gather(k = \"k\", v = \"shares\", 2:4) %>%\n  ggplot(aes(x = iteration, y = shares, color = k)) + geom_line(size =1.2)\n\np1 / p2\n```\n\n::: {.cell-output-display}\n![](Multinomial_Logit_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\nFirst order conditions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns_in + (theta_post*der) %*% (p_new - mc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         [,1]\n[1,] -0.01620\n[2,] -0.00271\n[3,]  0.01573\n```\n:::\n:::\n\n\nThat's it.\n\nIn the next example we'll show a bit more complicated example of [ One level Nested logit](nested.qmd). Also, the code will be warped up in functions for production. \n",
    "supporting": [
      "Multinomial_Logit_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}