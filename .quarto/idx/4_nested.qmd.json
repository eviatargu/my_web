{"title":"Nested Logit","markdown":{"yaml":{"title":"Nested Logit","editor_options":{"chunk_output_type":"console"}},"headingText":"load packages","containsRefs":false,"markdown":"\n\n```{r loading packages etc., include = T, warning=FALSE, message=FALSE}\nlibrary(tidyverse)\noptions(scipen = 999, digits = 3)\n```\n\n# 1. Introduction\n\nIn the previous document we saw a simplified example of merger simulation with multinomial logit. The next example is a step up in complexity. We'll replace the model to a One Level Nested Logit. this model allows somewhat more realistic substitution patterns between products. In addition, this document will present the code warped up in functions that take care of several stages of the process.\n\nTo perform the simulation we'll go thorough 4 stages:\n\n1.  Prepare the data\n2.  Calculate derivative matrix for the One-level nested logit demand system based on Price, market shares, Alpha and Sigma.\n3.  Solve a system of equations that characterize the first order condition of the assumed supply side - Bertrand competition with differentiated products.\n4.  Calculate a post merger new equilibrium based on post merger system of equations.\n\nWe'll present five functions that perform each of those steps and briefly review some key points.\n\n# 2. Functions\n\n## 2.1. Data preparation\n\nPrepare data set - `f1_init_calibration` creates a new data frame in the global environment with necessary variables for the simulation.\\\nThe new data frame's name is `calibration data`.\n\nWhen calling the function all arguments must be specified:\n\n\\(1\\) data frame that includes the columns listed next. (2) `p`: product prices. (3) `q`: quantities sold for each product. (4) `firm`: the firm that owns the product. (5) `nest`: the group of products the product belongs to according to the model specified the the researcher. (6) `m_size`: The market size assumed by the researcher. (The choice of market size actually determines the size of the outside option. This choice has a decisive effect on the results of the simulation, but this subject is beyond the scope of this document). (7) `buyer`: The acquirer firm. (8) `seller`: the purchased firm.\n\n```{r}\nf1_init_calibration <- function(data, p, q, firm, nest, m_size, buyer, seller){\n  \n  data <- data %>%\n    rename(p = {{p}}, q = {{q}},firm = {{firm}}, nest = {{nest}}, m_size = {{m_size}})\n  \n  nest_mat <<- outer(data$nest, data$nest, FUN = \"==\") * 1 # nest matrix\n  \n  calibration_data <<-\n    data %>%\n    select(p, q, firm, nest, m_size) %>%\n    mutate(\n      p = as.numeric(p),\n      q = as.numeric(q),\n      s = q / m_size,                   # product market share \n      s_0 = 1 - sum(s),                 # outside option market share\n      s_g = as.numeric(nest_mat %*% s), # share of each nest\n      s_jg = s / s_g,                   # share of product j in nest g\n      firm_post = if_else(firm == {{seller}}, {{buyer}}, firm),\n      n = n()) %>% na.omit()\n}\n```\n\n## 2.2. Derivative matrix\n\n`f2_derivatives` builds and returns the derivative matrix from the shares, alpha and sigma.\\\nIn one level nested-logit there are 3 types of derivatives:\\\n(1) Own derivative (which should be all negative -\\> demand goes down as price goes up)\n\n\\(2\\) cross derivative for products in the same nest.\n\n\\(3\\) cross derivative for products in a different nest. (These are the same as the cross derivatives in the Multinomial Logit model)\n\n```{r}\nf2_derivatives <- function(shares, nest_shares, alpha, sigma){\n  \n  # preparations\n  s     <- shares\n  s_jg  <- nest_shares\n  n     <- length(s)\n  alpha <- - abs(alpha) # to avoid confusion. fix the sign of alpha\n  \n  # derivatives\n  cross_different  <- - alpha * s %o% s * (1 - nest_mat)\n  \n  cross_same <- \n    - alpha * (sigma / (1 - sigma) * s_jg + s) %o% s * nest_mat *\n    (1 - diag(x = 1,nrow = n))\n  \n  own <- alpha * s * (1 / (1-sigma) - sigma / (1-sigma) * s_jg - s)\n  \n  # warp it in the matrix\n  derivatives <- cross_different + cross_same + diag(own)\n  derivatives\n}\n```\n\n## 2.3. Pre-merger conditions\n\n`f3_pre_merger_conditions` gets as inputs the `calibration_data` we created in the global environment, a `derivatives` matrix and the assumed $sigma$, the parameter for correlation between products in the same nest.\n\n`f3_pre_merger_conditions` solves the first order condition of the equation system, and calculates several supplemented variables:\\\n(1) Profit margins and (2) Lerner index to check profitability, the (3) Delta which is the mean utility the consumer has with the prevailing prices and a (4) FOC condition to see if the iteration process that will come next converges to zero.\\\nThe new variables are added the the `calibration_data` in the global environment.\n\n```{r}\nf3_pre_merger_conditions <- function(c_data, derivatives, sigma){\n  \n  theta <- outer(c_data$firm, c_data$firm, FUN = \"==\") * 1 # ownership matrix\n  s <- c_data$s\n  p <- c_data$p\n\n  # system solution for marginal costs  \n  c_data$mc <- solve(derivatives * theta) %*% s + p \n  \n  c_data <- c_data %>%\n    mutate(margin = p - mc,\n           lerner_index = (p - mc) / p,\n           FOC = as.vector(s + (theta * derivatives) %*% (p - mc)),\n           delta =  log(s / s_0)  - sigma * log(s_jg)\n           )\n  \n  calibration_data <<- c_data\n}\n```\n\n## 2.4. Simulate the merger\n\n### 2.4a. Nested logit Demand function\n\nIn the process of looking for a new equilibrium after the merger, we need to use the consumers demand function. Every time the prices change, the mean utility of the consumer changes, hence the quantity demand will change. `f5_demand` is the demand function. It calculates the market shares that will prevail given a vector of prices. Its arguments are `delta`- the mean utility from consumers have for each product, and $sigma$ - the in-nest correlation parameter according to the nested logit model.\\\nThe user need not operate this function. It will be called from within `f4_fixed_point` that will calculate the new equilibrium.\n\n```{r}\nf5_demand <- function(delta, sigma){\n  \n  # demand function\n  exponent    <- exp(delta /(1-sigma))\n  D_g         <- unique(nest_mat, MARGIN = 1) %*%  exponent\n  denominator <- D_g ^ sigma * (1 + sum(D_g^(1-sigma)))\n  s_t         <- as.vector(exponent * unique(nest_mat, MARGIN = 2) %*% (1/ as.vector(denominator)))\n  \n  # nest shares\n  s_g  <- as.numeric(nest_mat %*% s_t)  # nest market share\n  s_jg <- s_t / s_g                     # share within the nest\n  \n  data.frame(s_t = s_t, s_jg_t = s_jg, delta_t = delta, n = length(s_t))\n}\n```\n\n### 2.4b. Fixed point iteration\n\n`f4_fixed_point` calculates the new equilibrium with a fixed point iteration algorithm.\\\nIt uses the `f5_demand` `f2_derivatives` and solves the FOC iteratively until solution is reached or until the maximum number of iterations is reached.\\\nThe user has control over the maximum number of iterations and the tolarance desired for convergence.\\\nwe shall expand about the argument `convergence_factor` later.\n\n```{r}\nf4_fixed_point <- \n  function(data, alpha, sigma, max_iter = 100,\n           convergence_factor = 1, tolerance = 1e-3){\n    \n    theta_post <- outer(data$firm_post, data$firm_post, FUN = \"==\") * 1\n    s_in       <- data$s\n    p          <- data$p\n    mc         <- data$mc\n    delta      <- data$delta\n    der_new    <- f2_derivatives(calibration_data$s, calibration_data$s_jg, alpha, sigma)\n    log         <- matrix(nrow = max_iter, ncol = length(s_in) + 2)\n    i          <- 0\n    s_d_norm   <- 1\n    \n    while(i < max_iter & s_d_norm > tolerance){\n      \n      i         <- i + 1\n      p_new     <- mc - (solve(der_new * theta_post)) %*% s_in  # new price\n      delta_new <- delta - abs(alpha) * as.vector((p_new - p)/ convergence_factor)\n      s_new     <- f5_demand(delta_new, sigma)\n      der_new   <- f2_derivatives(s_new$s_t, s_new$s_jg_t, alpha, sigma)\n      s_d_norm  <- sqrt(sum((s_in - s_new[[1]]) ^ 2)) # measure convergence\n      s_in      <- s_new[[1]]    # new price vector to feed in\n      log[i,]    <- c(p_new, norm = s_d_norm,iteration = i) # results\n      \n    }\n    \n    log       <- data.frame(log) %>% drop_na()\n    names(log)<- c(paste(\"p\", 1:length(s_in), sep = \"_\"), \"norm\", \"iter\")\n    simulation_log <<- log\n    \n    tail     <- tail(log,1)\n    \n    data$new_prices <- tail %>% select(starts_with(\"p_\")) %>% t() %>% as.vector()\n    data$iterations <- tail %>% select(iter) %>% pull()\n    data$norm       <- tail %>% select(norm) %>% pull()\n    data$new_shares <- s_new[[1]]\n    \n    calibration_results <<- data %>%\n      select(firm, nest, p, new_prices, s, new_shares,\n             iterations, norm, q, m_size)\n    \n    \n  }\n```\n\n# 3. Simulation\n\n## 3.1 Build toy data\n\nIts about time to see it all in action.\n\nwe'll create a toy data of 6 products owned by 3 firms, divided into 2 nests.\\\nmarket size will be 100.\n\n```{r}\ndf <- data.frame(\n  company  = c(\"a\",     \"a\",     \"b\",    \"b\", \"c\", \"c\"),\n  nests    = c(\"pre\",   \"pre\",   \"pre\",   2,   2,   2),\n  quantity = c( 20,      5,       10,     5,   10,  25),\n  price    = c( 60,      40,      50,     45,  30,  30),\n  m_size   = 100,\n  not_needed_variable = \"junk\")\ndf\n```\n\nWe can prepare the data for simulation using `f1_init_calibration`:\\\nNote that all argument are needed for the function to know which variable is which:\\\nprices, quantities, firm, nest, market size, buyer and seller.\n\n```{r}\nf1_init_calibration(df, p = price, q = quantity, firm = company, nest = nests,\n                    m_size = m_size, buyer = 'a', seller = 'b')\n```\n\nA new df named`calibration_data` was created in the global environment:\n\n```{r}\ncalibration_data\n```\n\n## 3.2. Assume regression results\n\nIf one does a Nested Logit demand estimation successfully , one has the right $sigma$ and $alpha$ to put into the simulation. here, we assume those parameters to be:\n\n```{r}\nsigma0.5 <- 0.5\nalpha0.1 <- 0.1\n```\n\nThis does not have to be an arbitrary assumption, rather it can be based on the knowledge we have about the market.\n\n## 3.3. Checking Derivatives\n\nLets see how the derivative matrix is like for this toy data.\\\nIn actual simulation this function is being called from `f4_fixed_point`, so there is no need to call it.\n\n```{r}\nder <- f2_derivatives(calibration_data$s, calibration_data$s_jg, alpha0.1, sigma0.5)\nder\n```\n\nGlimpsing on it, it look like the own derivative in the diagonal is negative and the rest is positive.\n\n## 3.4. Pre-merger conditions\n\nNow we calculate the marginal costs of the firms. all new variables are added to the `calibration_data` .\n\n```{r}\nf3_pre_merger_conditions(calibration_data, der, sigma0.5)\ncalibration_data\n```\n\n## 3.5. Check the demand system\n\nFor the sake of presentation, lets see that the demand function works correctly.\\\nFeeding the delta's consumers had, we should get the same market shares we assumed.\\\nEvery time the price will change, the delta will change and so the shares.\n\n```{r}\nf5_demand(calibration_data$delta, sigma0.5)\n```\n\nWe got the same market shares we chose when we first built our toy data, so its OK.\n\n## 3.6. Simulate the merger\n\nAt last, we can simulate the merger.\\\nUsing the fixed point iteration, we get a new df named `calibration_results` with the results of the simulation.\n\n```{r}\nf4_fixed_point(calibration_data, alpha0.1, sigma0.5, convergence_factor = 1.2)\ncalibration_results\n```\n\n`calibration_results` gives the new prices and new shares, reports how many iterations were needed to converge to the tolerance of 1/1000 and reports the norm of the change in prices in the last iteration.\n\nWe can watch the entire process in the `simulation_log` object created in the global environment.\n\n```{r}\nrbind(head(simulation_log),tail(simulation_log))\n\nsimulation_log %>% select( - norm) %>%\n  pivot_longer(1:6) %>%\n  ggplot(aes(x = iter, y = value, color = name)) + geom_line()\n\n```\n\nNote that when we called `f4_fixed_point` we used a `convergenc_factor` of 1.2.\\\nAs it happens, this data consists of only 6 observations and the fixed point algorithm doesn't converge naturally with a `convergence_factor` of 1.\\\nAt best practice, one should use a `convergence_factor` of 1, and only if there's a problem to choose a `convergence_factor` \\> 1.\\\nLets see what happens if we chose `convergence_factor` = 1.\n\n```{r}\nf4_fixed_point(calibration_data, alpha0.1, sigma0.5, convergence_factor = 1)\n\n```\n\nPrices and shares are constantly jumping between two points.\n\n```{r}\nsimulation_log %>% select( - norm) %>%\n  pivot_longer(1:6) %>%\n  ggplot(aes(x = iter, y = value, color = name)) + geom_line()\n```\n\n`calibration_resaults` also tells us that the `norm` is far far away from zero:\n\n```{r}\ncalibration_results\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"4_nested.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.36","editor":"visual","theme":"Flatly","title":"Nested Logit","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}}}