{"title":"Multinomial Logit Example","markdown":{"yaml":{"title":"Multinomial Logit Example"},"headingText":"introduction","containsRefs":false,"markdown":"\n\n```{r loading packages etc., include = T, warning=FALSE, message=FALSE, include=FALSE}\noptions(scipen = 999,digits = 3)\n\n```\n\n\nIn this document I'll demonstrate merger simulation with a synthetic example. On the supply side assuming a differentiated Bertrand model and on the demand side assuming a multinomial logit demand function.\n\nThe Bertrand system of equations has 4 components:\\\n(1) Market shares.\\\n(2) Prices.\\\n(3) Derivatives of the demand function with respect to the prices.\\\n(4) Marginal costs of the firms.\n\n# Pre merger conditions\n\nFor the sake of demonstration the market shares chosen are `0.2, 0.25` and `0.3`.\\\nprices are `50, 75` and `80` correspondingly.\n\n```{r, collapse= TRUE}\n# 1. market shares\ns <- c(0.2, 0.25, 0.3) \n\n# outside option market share\n(s_0 <- 1 - sum(s) )\n\n# 2. prices\np <- c(50, 75, 80)\n```\n\n**Calculation of derivatives**\\\nThe logit derivative is a function of market shares and the consumer's derivative with respect to the price - the model's $alpha$. we'll choose $alpha$ to be 0.1. In fact, this is a calibration of the system. One can estimate those parameters with a demand estimation (which is beyond the scope of this simple document).\n\n```{r, collapse= TRUE}\n# 3. derivatives\n# choose alpha  \nalpha <- - 0.1\n\n# derivatives are functions of market shares and alpha\n# own derivative\n(d_sj_d_pj <- alpha * (1-s) * s)\n\n# cross derivative\n(d_sk_d_pj <- - alpha * s %o% s)\n\n# put own derivatives in diagonal\nder <- d_sk_d_pj\ndiag(der) <- d_sj_d_pj\n\n# final result\nder\n```\n\nNote that the diagonal is negative -\\> self elasticity is negative, and the off-diagonal are positive which means products are substitutes.\n\n**Solving the equation system for the marginal costs**\\\nAs stated above, First order condition has 4 components.\\\nWe have supplied the market shares, the prices and the derivatives. Next, we solve the system for the marginal costs.\n\nFor the solution we create the \"owner ship\" matrix:\n\n```{r}\n# 4. solving a system of equations for the marginal costs\n# ownership matrix\n(theta <- matrix( c(1,0,0,0,1,0,0,0,1), nrow = 3))\n\n# solve a system of linear equations\n(mc <- solve(theta * der) %*% s + p )\n```\n\nWe can check the first order condition are valid.\n\n```{r}\n# check that F.O.C's are met: \ns + (theta * der) %*% (p - mc)\n```\n\n# Merger simulate\n\n**A merger in the market**\\\nWhen a merger happens, the ownership of firms over the product set is changing. Next, we'll assume that products 1 and 2 are now under the same ownership. For that, we update the ownership matrix. The 1st and 2nd elements 1st and 2nd rows of the matrix will equal to 1:\n\n```{r}\n# new ownership matrix: \n(theta_post <- matrix(c(1,1,0,1,1,0,0,0,1), nrow = 3))\n```\n\nChanging the ownership matrix resembles the change in the incentives the merged firm forgo. The firm understands that when the price of product 1 goes up, some of the customers that choose to not buy it anymore will by product 2. The closer substitutes are the products the larger proportion of customers will diverge between product 1 to 2 and vice versa. Hence for those customers, the firm does not loose its sails. With that knowledge, the firm can raise the price up. The first order condition is not valid anymore because the old price is not the optimal price.\n\n```{r}\n# FOC don't hold\ns + (theta_post * der) %*% (p - mc)\n```\n\n## Fixed point iteration\n\nThis change in the merged firm incentives has a ripple effect on the entire market. The firm will raise its prices, some of the customers will leave its products and either buy it at the competitors or not buy it at all. To compute this, we need an iterative process that will end in a new equilibrium.\n\nAssuming convexity and continuity of the equation system, we can find a solution and know it is unique.\n\naccording to the model , the average utility from product j is: $$ \\delta_j = x \\beta_j - \\alpha p + \\xi _j $$\\\nFor each product we calculate the average utility.\n\nA change in price will change the utility from the product. This in turn, will be reflected in the demand function, the demand decreases when the price goes up and vice versa.\n\n```{r}\n# delta = x * b - alpha * p\n(delta <- log(s / s_0)) \n\nexp(delta) / (1 + sum(exp(delta)))\n```\n\n## Manual iteration\n\nWe'll compute the first few iterations be hand to see how it converges.\\\nIn every iteration 4 stages will take place:\n\n(1) Solve the firms first order conditions subject to market shares to find a new price vector.\n(2) Calculate the change in the price vector compared to the pre-merger state.\n(3) feed the new prices to consumer utility functions to get the change in utilities.\n(4) Get the new market shares out from the demand function.\n\n```{r}\n# the price update procedure: \n# 1. solve FOC 1\n(p1 <- as.vector(mc + (1/ - alpha) * (1 / (1 -  theta_post %*% s))))\n# 2. delta price\n(d_p <- (p1 - p))\n# 3. delta in utility\n(d_delta <- d_p * alpha)\n# 4. solve demand for new utility\n(s1 <- exp(delta + d_delta) / (1 + sum(exp(delta + d_delta))))\n```\n\nGet the results and compere to the pre merger status.\n\n```{r}\nresults <-rbind(c(s, p), c(s1, p1)) \nresults\n```\n\nRepeat the process several more times.\n\n```{r}\n# solve FOC 2:\np2 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s1)))\nd_p <- (p2 - p) \nd_delta <- d_p * alpha\n# solve demand 2:\ns2 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s2, p2))\n# solve FOC 3:\np3 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s2)))\nd_p <- (p3 - p) \nd_delta <- d_p * alpha\n# solve demand 3:\ns3 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s3, p3))\n# solve FOC 4:\np4 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s3)))\nd_p <- (p4 - p) \nd_delta <- d_p * alpha\n# solve demand 3:\ns4 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s4, p4))\n# solve FOC 5:\np5 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s4)))\nd_p <- (p5 - p) \nd_delta <- d_p * alpha\n# solve demand 3:\ns5 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s5, p5))\n# solve FOC 6:\np6 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s5)))\nd_p <- (p6 - p) \nd_delta <- d_p * alpha\n# solve demand\ns6 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s6, p6))\n# solve FOC 7:\np7 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s6)))\nd_p <- (p7 - p) \nd_delta <- d_p * alpha\n# solve demand\ns7 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\nresults <- rbind(results, c(s7, p7))\n# solve FOC 8:\np8 <- as.vector(mc + (1/ -alpha) * (1/(1 -  theta_post %*% s7)))\nd_p <- (p8 - p) \nd_delta <- d_p * alpha\n# solve demand\ns8 <- exp(delta + d_delta) / (1 + sum(exp( delta + d_delta)))\n```\n\nIn the `results` matrix, columns 1-3 are market shares and columns 4-6 are the prices.\\\nevery iteration the jumps in the values decreases.\n\n```{r}\nresults <- rbind(results, c(s8, p8))\ncolnames(results) <- c('s1', 's2', 's3', 'p1', 'p2', 'p3')\nresults\n```\n\nWe can see where it's going. the shares of products 1 and 2 are decreasing and product 3 is increasing. All prices are going up.\n\nLets calculate the new equilibrium.\n\n## While loop\n\nWe'll limit the number of iterations with `max_iter`, and document the convergence process in a `convergence_matrix` .\n\n```{r}\nmax_iter <- 82 \ns_in <- s\ni <- 0\ns_delta_norm <- 1\nconvergence_matrix <- matrix(nrow = max_iter, ncol = length(s) * 2 + 2)\n\nwhile(s_delta_norm > 1e-6 & i < max_iter){\n  i <- i + 1\n  \n  # solve F.O.C\n  ( p_new <- as.vector(mc + (1/ - alpha ) * ( 1 / (1 -  theta_post %*% s_in) )))\n  \n  # change in utility\n  d_delta <- (p_new - p) * alpha\n  \n  # solve demand system\n  s_new <- exp(delta + d_delta) / (1 + sum(exp(delta + d_delta)))\n  \n  # norm of change in market shares\n  (s_delta_norm <- sqrt(sum((s_in - s_new) ^ 2)))\n  \n  # save resault for next iteration\n  s_in <- s_new\n  \n  convergence_matrix[i, ] <- c(s_new,  p_new, s_delta_norm, i)\n}\n\ncolnames(convergence_matrix) <- c(\"s1\", \"s2\", \"s3\", \"p1\", \"p2\", \"p3\", \"norm\", \"iteration\")\n\nconvergence_matrix\n```\n\nCompare the data before the merger with the prediction of the simulation about the merger effect on prices and market shares\n\n```{r}\n# attach preconditions with last row without NA's in the matrix\nfinal_resault <- \n  convergence_matrix[tail(which(rowSums(!is.na(convergence_matrix)) > 0), 1),]\n\n\nrbind(c(results[1,],norm = NA,iteration = 0),final_resault)\n```\n\nThe market share of the outside option has increased:\n\n```{r}\nc(before = s_0, after = 1 - sum(final_resault[1:3]))\n```\n\nPresent convergence process on a plot\n\n```{r, warning=FALSE}\npacman::p_load(tidyverse, patchwork)\n\np1 <- data.frame(convergence_matrix) %>%\n  select(iteration, p1, p2, p3) %>%\n  gather(k = \"k\", v = \"prices\", 2:4) %>%\n  ggplot(aes(x = iteration, y = prices, color = k)) + geom_line(size = 1.2)\n\np2 <- data.frame(convergence_matrix) %>%\n  select(iteration, s1, s2, s3) %>%\n  gather(k = \"k\", v = \"shares\", 2:4) %>%\n  ggplot(aes(x = iteration, y = shares, color = k)) + geom_line(size =1.2)\n\np1 / p2\n```\n\nFirst order conditions:\n\n```{r}\ns_in + (theta_post*der) %*% (p_new - mc)\n```\n\nThat's it.\n\nIn the next example we'll show a bit more complicated example of [One level Nested logit](4_nested.qmd). Also, the code will be warped up in functions for production.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"3_multinomial_logit.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.36","editor":"visual","theme":"Flatly","title":"Multinomial Logit Example"},"extensions":{"book":{"multiFile":true}}}}}